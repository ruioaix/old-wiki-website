= 标准I/O库 =
前面说了很多的文件I/O操作，不同的头文件，操作的都是linux上直接的文件目录。

对，前面的文件I/O，就是告诉你怎么操作linux上的文件和目录。

接下来的每一个章节，又会告诉你怎么操作linux上的这个那个。

文件I/O操作要么针对文件描述符，要么是直接的pathname。而标准I/O则是围绕流进行的。

流，暂时不知道是个什么东西。但是其一个属性是定向，定向就是其所读的字节是单字节还是多字节。
- `#include <stdio.h>`
- `#include <wchar.h>`
- `int fwide(FILE *fp, int mode);`

*对一个进程预定义了三个流，并且这三个流可以自动地被进程使用，它们是：标准输入、标准输出、标准出错。*
- 原来这三个是对进程来说的，其实也是必然是对进程来说的。
- 原来这三个是流啊。
- 这三个通过预定义文件指针stdin、stdout、stderr加以使用。

== 缓冲 ==
标准I/O库提供缓冲的目的是尽可能减少使用read和write调用的次数。

标准I/O提供了三种类型的缓冲：
# 全缓冲——I/O缓存区填满后才进行实际I/O操作。在一个流上执行第一次I/O操作时，相关标准I/O函数通常调用malloc获得需使用的缓冲区。
    - 在一个流上执行I/O操作，也就是说流需要和某一个确切的文件联系起来。
    - 全缓冲通常用于驻留在磁盘上的文件，也就是操作磁盘上的文件，比如写入数据到磁盘文件上的时候。
    - 缓冲区可由标准I/O自动冲洗（填满），也可以调用函数fflush冲洗。冲洗——将缓冲区写入磁盘。
    - 对于终端来说，flush意味着丢弃存储在缓冲区中的数据。
# 行缓冲
    - 当在输入和输出中遇到换行符时，标准I/O库执行I/O操作。
    - 对于终端来说，一般都使用行缓冲。
    - 终端的输入，也就是在回车之后被读入的。写输入的过程是行缓冲吗？
    - 终端的输出？
    - 流和终端联系的时候，通常使用行缓冲。
    - 行缓冲的限制
        - 行缓存的缓冲区长度固定，当填满时，即使没有换行符，也执行I/O
        - 从内核获取数据，意思是要求内核使用read函数读数据过来，虽然我明白这句话的意思，但我想不到合适的比喻，就是说标准I/O要求从一个带行缓冲的流中得到输入数据时，那么就冲洗所有行缓冲的输出流，因为数据可能已经在该缓冲区了。。。。你妈的，什么乱七八糟的。。。
# 不带缓冲
    - 标准出错流stderr通常是不带缓冲的。

`void setbuf(FILE *restrict fp, char *restrict buf);`
`int setvbuf(FILE *restrict fp, char *restrict buf, int mode, size_t size);`

一般而言，应由系统选择缓冲区的长度，并自动分配缓冲区。在这种情况下关闭此流时，标准I/O库将自动释放缓冲区。

任何时候，我们都可以强制冲洗一个流：
- `#include <stdio.h>`
- `int fflush(FILE *fp);`
    - 此函数使该流所有未写的数据都被传送至内核。
    - 内核负责写入磁盘文件吗，write函数，所以也就是说传给内核，内核输出。

== 打开流 ==
打开一个标准I/O流
- `FILE *fopen(const char *restrict pathname, const char *restrict type);`
    - 第一个函数打开一个文件，并返回一个流。
    - 返回的流和这个文件就结合起来了。
    - 以后对流的操作，就是对文件的操作。
- `FILE *freopen(const char *restrict pathname, const char *restrict type, FILE *restrict fp);`
    - 第二个函数在一个指定的流上打开一个文件
    - 并返回这个流。
    - 此函数一般用于将一个指定的文件打开为一个预定义的流。
- `FILE *fdopen(int filedes, const char *type);`
    - 第三个函数获取一个文件描述符，将返回的流与之结合。
    - 特殊类型的文件不可以被fopen打开，所以用特殊的函数打开然后返回一个描述符，这个描述符就可以被这个函数使用了。
- fdopen对于为写而打开的并不截断该文件。fdopen得到的是描述符。也就是已经被打开了，打开的时候使用的函数决定了是否截断。fdopen本身不截断任何关联的文件。

当进程正常终止时（直接调用exit函数，或从main函数返回），则所有带未写缓冲数据的标准I/O流都会被冲洗，所有打开的标准I/O流都会被关闭。

== 读和写流 ==
一次读一个字符
- `#include <stdio.h>`
- `int getc(FILE *fp);`
- `int fgetc(FILE *fp);`
- `int getchar(void);`
- 这三个函数是对一个字符，也就是一个unsigned char，现在这三个函数返回的是int类型，也就是执行了从unsigned char到int的转换，这样不会有任何的损失。
- 这三个函数在出错和到达文件尾端（就是没成功读取），这三个函数都返回同样的值。
- `int ferror(FILE *fp);`
    - 是否出错
- `int feof(FILE *fp);`
    - 是否到达文件尾部。
- `void clearerr(FILE *fp);`

输入流，输出流，是什么意思。
- 输入，记得read函数，就是读，读就是输入，读什么，读文件，那么输入流呢，就是从流中读。
- 输出流，就是向流中写入。

输出一个字符到流中
- `int putc(int c, FILE *fp);`
- `int fputs(int c, FILE *fp);`
- `int putchar(int c);`

== 每次一行I/O ==
每次从流中读一行
- `char *fgets(char *restrict buf, int n, FILE *restrict fp);`
- `char *gets(char *buf);`
    - fgets的buf总是以null字符结尾的。
    - 如果一行不到n-1的长度，那么读入的是完整的行，然后加上null
    - 如果一行超过了n-1的长度，那么读入了n-1个字符，也就是不完整的行，然后加上null。
        - 然后fgets的下一次调用会继续读该行。
    - gets不指定缓冲区长度，也就是说比如它有100的长度，但终端一行写入了110，那么buf之后的10个字符空间就被非法使用了，也就是缓冲区溢出了。
    - gets因为从终端读入，所以最后一个换行符总是不保存的。（终端输入最后一个回车吗）。

每次向流中写入一行
- `int fputs(const char *restrict str, FILE *restrict fp);`
- `int puts(const char *str);`
    - fputs将以null结尾的字符串写入流，但不要求null前面是换行符，也就是说不要求字符串是一行。null字符不写入。
    - puts将以null结尾的字符串写入流，null字符不写入，然后再写入一个换行符。

== 标准I/O的效率 ==
系统调用与普通的函数调用相比通常需要花费更多的时间。

对于大多数比较复杂的应用程序，最主要的用户cpu时间是由应用本身的各种处理消耗的，而不是由标准I/O例程消耗的。

== 二进制I/O ==
二进制文件中会包含null和换行符，这些都是有用的。

如果使用fputs和fgets，那么会忽略null，造成数据读取和写入的失败。

二进制I/O操作的函数
- `#include <stdio.h>`
- `size_t fread(void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);`
- `size_t fwrite(const void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);`
- 使用二进制I/O的基本问题是，它只能用于读在同一个系统上已写的数据。
- 不同系统上的二进制数据格式可能不同。

== 定位流 ==
定位流，定位文件。有些混乱。

== 格式化I/O ==
格式化输出
- `#include <stdio.h>`
- `int printf(const char *restrict format, ...);`
- `int fprintf(FILE *restrict fp, const char *restrict fomat, ...);`
- `int sprintf(char *restrict buf, const char *restrict format, ...);`
- `int snprintf(char *restrict buf, size_t n, const char *restrict format, ...);`
    - sprintf会在buf尾部加上一个null，但该字节不包含在返回值中。

格式化输入
- `int scanf(const char *restrict format, ...);`
- `int fscanf(FILE *restrict fp, const char *restrict format, ...);`
- `int sscanf(const char *restrict buf, const char *restrict format, ...);`

== 实现细节 ==
每一个标准I/O流都有一个与其相关联的文件描述符。
- `int fileno(FILE *fp);`

RHEL6：
- 当标准输入、标准输出连至终端时，它们是行缓冲的，行缓冲区的长度是1024字节；也就是说，如果要将2048字节的行写到标准输出，则要进行两次write系统调用，就是说1024满了的时候，调用一次write，将缓冲区的内容写入到标准输出描述符里面。然后再一次。
- 当标准输入、标准输出连至普通文件时，它们就变成是全缓冲的，其缓冲区长度是该文件系统优先选用的I/O长度。
- 标准出错是非缓冲的。

流总是和文件描述符关联。当写入的时候，对于流来说，就是fputs，fputc，printf等等，这些都是将一些写入流中，准确的说是写入流缓冲区中，然后，在流缓冲区满了的时候，或者其他一些满足要求的时候，内核就会调用write函数，将流缓冲区中内容写入流所对应的文件描述符中。

当输出的时候，过程应该是相反的，先是内核读取文件描述符所对应的文件的内容到缓冲区，读满整个缓冲区？然后，使用getc，fgetc，fgets，scanf等来从缓冲区读取内容？是这样吗？

或者，不同的缓冲区类型不能一概而论。

或许是这样的，流就是缓冲，文件就是文件描述符，write和read直接操作文件描述符，直接操作，一次一个内核调用，无缓冲。底层总是这么实现的。然后在其上，出现了缓冲，流，流的出现就是为了减少write和read的直接调用次数，所以，设置了缓冲区，缓冲区满了你才能write，read的时候，也是直接从对应的文件读一个缓冲区长度的数据，放在缓冲区，然后，上面的你慢慢读，什么时候缓冲区空了，read再给你整满满一区。概念上应该是这么个概念。

实现的话，比如fgetc，读一个字符，从流中读一个字符，你使用这个函数的时候，参数是一个流，这个流已经和一个文件描述符对应了，你这里读一个字符，实际上，内和调用read读取的可不是一个字符。上面也做了实验，fgetc和每次读一个字符的read函数之间的比较，read函数读了2亿次，也就是说文件有2亿字符，所以读了两亿次吗，但是这2亿个字符，fgetc只引起了25222次系统调用，这说明了什么，说明了fgetc调用系统函数时并不是每次读一个字符，它读的更多，放在了缓冲里而已。

fputc也好理解，每次放在了缓冲里，最后一下调用系统函数，系统函数将缓冲区的数据一次放入文件描述符的文件里。

fgets呢，如何理解。底部应该是和fgetc一致的，事实上，fgets很可能是调用fgetc的，如果是这样，我就理解了。但是fgets还可能调用的是memccpy函数，这个我就不知道了，但也应该是有缓冲区的存在，memccpy操作的也应该是缓冲区吧。

那printf呢，这个是和终端联系在一起的，输出函数，它将内容交给了终端流，终端流什么时候实际的将其缓冲区内容输出到终端输出描述符呢，满了的时候吧。
scanf呢，也和终端联系在一起，首先是从终端获取数据，这个应该是立即的，首先，从终端输入文件描述符中得到数据，缓冲区大概也就那么大，然后获得数据。可能对于scanf来说，缓存区反而是多余的步骤。但存在即有理。

其他的一些函数，比如fprintf，我就好理解了，放入流中，其实先理解了这种函数，再去理解printf要好理解的多。

对于fscanf，也是，从流中取数据放入变量中，也是可以理解的。

这些所有的标准I/O函数，都是对应与流，而流对应与文件描述符，文件描述符对应于系统调用，流就是缓冲区，标准I/O操作的都是缓冲区。
 
== 临时文件 ==
RHEL6上使用tmpnam时，编程给出了警告，说使用mkstemp比较安全。

== 标准I/O的替代软件 ==
当使用每次一行的函数fgets和fputs的时候，通常进行两次复制，一次在内核和标准I/O的缓冲之间（也就是调用read和write的时候），第二次是在标准I/O缓冲区和用户程序中的行缓冲区之间。
- 这里才发现还有个用户程序中的行缓冲区之间，这个是啥呢？
- 是fgets从缓冲区取数的过程，这里的行缓冲区更多的是一个数组类型的buf吧。

=OVER=

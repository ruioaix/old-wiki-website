= 信号 =

信号是软件中断，必须要学会的。

== 信号概念 ==
linux支持31种不同的信号。linux支持应用程序额外定义的信号。

这些信号都被定义为正整数。

很多条件可以产生信号：
# 在终端中ctrl+c，产生中断信号（SIGINT），这是停止一个已失去控制的程序的方法。
# 硬件异常产生信号；这些异常通常由硬件检测到，并通知内核，内核再发送SIGSEGV等信号给产生该异常的进程。
# 进程调用kill函数可将信号发送给另一个进程或进程组。
    - 接受信号和发送信号的进程所有者必须相同
    - 或者，发送信号进程的所有者必须是超级用户
# 用户使用kill命令，这个命令调用kill函数。
# 某些软件条件发生；如SIGALRM（进程所设置的闹钟时钟超时时产生）。

*进程不能简单地测试一个变量来判断是否出现了一个信号，而是必须告诉内核“在此信号出现时，请执行下列操作”*
- 这是进程处理信号的机制
- 进程对信号要时刻准备着
- 进程对信号的处理在某种程度上是不可控的，进程必须一开始就设置好什么样的信号什么样的处理，信号来了的时候，就那么处理；而不是说，信号来了，进程再想该如何处理该信号。

内核在信号出现时的处理：
# 忽略信号。
    - 但有两种信号不能被忽略，SIGKILL，SIGSTOP。这使得root总能停止他需要停止的进程。
# 捕捉信号。
    - 就是上面说的事先定义好函数，然后信号来了的时候，按部就班的执行。
    - 但SIGKILL，SIGSTOP不能被捕捉。
# 执行系统的默认操作。
    - 如此看来，上面的两个特殊信号就只有执行系统的默认操作了。

core文件在linux里是如何的？
- 使用`ulimit -a`看到core size是0，貌似linux默认没有开启core文件。

可以记得的信号有：
- SIGABRT，SIGALRM，SIGCHLD，SIGINT，SIGKILL，SIGSTOP，SIGTERM，SIGUSR1，SIGUSR2。

== signal函数 ==
函数
- `#include <signal.h>`
- `void (*signal(int signo, void (*func)(int)))(int);`
- 这里，signal是函数名，函数的返回值是一个函数指针，函数的参数是一个int和一个函数指针。
- 参数int就是信号
- 参数func对应前面的三种内核处理信号的方式，可以是SIG_IGN,SIG_DEL，和用户函数指针。
    - 如果是用户函数指针，那么，这个函数就是信号处理函数。
    - 至于SIG_IGN,SIG_DEL一般使用这样的定义：`#define SIG_ERR (void (*)())-1`。

== 不可靠的信号 ==
都是早期的信号系统的不可靠性，主要在几个方面：
- 用户函数，只会处理一次信号。
- ……

== 中断的系统调用 ==
系统调用分为两类：
- 低速系统调用
- 其他系统调用

低速系统调用指可能会使进程永远阻塞的一类系统调用。

== 可重入函数 ==
*进程捕捉到信号并对其进行处理时，进程正在执行的指令序列就被信号处理程序临时中断，它首先执行该信号处理程序中的指令*
- 可重入的函数，就是信号来了时候，正在执行的函数，然后这个函数被中断了，信号处理程序开始进行处理，处理完毕，从中返回，然后可以继续正确的处理之前正在执行的函数。这样的函数，是可重入函数。
- malloc和free，标准I/O函数，使用静态数据结构的函数，都是不可重入的。

每个线程只有一个errno变量，信号处理函数可能改变这个变量，可以理解，所以，在可重入函数的使用上，在调用函数之前应该保存errno，在调用之后回复errno。

== SIGCLD语义 ==


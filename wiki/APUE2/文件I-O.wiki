= 文件I/O =
本章是说：不带缓冲的I/O函数。

不带缓冲的I/O函数是POSIX.1的一部分，不是ISO C里的。

缓冲这个词，就是字面意思，I/O吗，输入输出，先甭管谁输入谁输出，反正就是有输入有输出，输入和输出连在一起，就像一扇门连着两个房间，那就是没有缓冲。如果输入一扇门，输出一扇门，两扇门之间还有一段通道，那么通道就算是缓冲了。

== 文件描述符 ==
就是数字，从0开始，到OPEN_MAX结束，这个OPEN_MAX是限制，也就是一个常量。

0与标准输入关联，1与标准输出关联，2与标准错误输出关联。头三个数字就没了。

== I/O函数 ==
- `int open(const char *pathname, int oflag, ...);` 成功返回描述符，出错-1。
- `int creat(const char *pathname, mode_t mode);` 同上。这个函数已经不必要了，open可以代替。
- `int close(int filedes);` 成功0，出错-1。
- `off_t lseek(int filedes, off_t offset, int whence);` 成功返回新的文件偏移量，出错-1。
- open函数使用时，如果没有O_APPEND选项，则文件偏移量为0。
- 文件偏移量大于文件当前长度，会构成一个空洞，这是允许的，空洞的字节都被读为0。这里是说读为，具体的空洞可能不占用空间。
- off_t就是系统数据类型了。不同的平台，内容不一样。
- `ssize_t read(int filedes, void *buf, size_t nbytes);` 成功则返回读到手的字节数，若读的时候已经到文件结尾了，则0，若出错则-1。
- `ssize_t write(int filedes, const void *buf, size_t nbytes);` 成功则返回写入的字节数，出错-1。
- ssize_t有符号，size_t无符号

== 文件共享 ==
UNIX系统支持在不同的进程间共享打开的文件。
- 进程记录了它所打开的文件的描述符和以及对应的文件表项的指针。
- 内核维护文件表，每个表项说明文件状态，偏移量，和v节点指针。
- v节点指针在文件系统中。
- 一个文件只有一个v节点。
- 但同一个文件可以在文件表中占据多个文件表项。
- 多个进程使用同一个文件表项是可能的。
- 多个进程使用同一个v节点是可能的，可能使用同一个文件表项，也可能各有各的文件表项，然后这些表项都指向一个v节点。
- 多个进程各有各的表项，所有的表项使用一个v节点也是可能的。

== 原子操作 ==
多进程操作同一个文件时，各个进程有自己的表项，然后表项指向同一个v节点，这是最常见的。

- `ssize_t pread(int filedes, void *buf, size_t nbytes, off_t offset);`
- `ssize_t pwrite(int filedes, const void *buf, size_t nbytes, off_t offset);`

== dup和dup2函数 ==
- `int dup(int filedes);`返回一个新的文件描述符，这个新的描述符和filedes这个描述符指向的都是同一个表项。
- `int dup2(int filedes, int filedes2);`filedes2是希望得到的描述符，如果filedes2和filedes一样，那么就返回；如果filedes2已经被什么使用了，那么关闭那个，然后再打开。成功的话，filedes2和filedes指向同一个表项。

== sync, fsync和fdtasync函数 ==
传统的UNIX实现在内核中设有缓冲区高速缓存或页面高速缓存，大多数磁盘I/O都通过缓冲进行。
- 磁盘I/O，就是对磁盘进行的I/O，向磁盘上写，从磁盘上读，向磁盘上写的时候大多应该是内存吧，也就是说将内存中的东西写入磁盘上，而从磁盘上读，显然也是将磁盘上的文件读到内存中。
- 不过对于读，貌似没有要求，重点在写上。
- 就是在内存和磁盘之间的I/O，有一个缓冲。
- 将数据写入文件时，内核将数据放入缓冲中，如果缓冲中没有写满，则不输出。
- 写满了，或者内核需要重用缓冲来存放其他磁盘块数据时，就将缓冲放入输出队列。
- 等输出队列一个一个的输出，也就是实际的I/O操作。
- 这种方式就是延迟写。
- 为了保证磁盘上实际文件系统与缓冲区高速缓存中内容的一致性，UNIX提供了sync，fsync和fdatasync三个函数。

`int fsync(int filedes);`对文件filedes这一个文件起作用，并且等待写磁盘操作结束。

`int fdatasync(int filedes);`同上类似，但上面的函数将文件的属性都修改了，本函数只是写入数据，不管属性等其他非数据部分。

`void sync(void);`将缓冲排入写队列。并不要求实际磁盘操作。

== fcntl函数 ==
`int fcntl(int filedes, int cmd, ...);`
函数可以改变已经打开的文件的性质。

第一个参数就是打开文件的文件描述符。函数的作用取决于第二个参数。根据第二个参数，第三个参数可以变换。

该函数的5种功能：
# 复制一个现有的描述符。和dup一个意思，但比dup更灵活，dup是最小可用的，本函数是从某个值开始最小可用的。
# 获得/设置文件描述符标记
# 获得/设置文件状态标记
# 获得/设置异步I/O所有权
# 获得/设置记录锁

文件描述符，文件描述符标志，文件状态，文件状态标志。

目前出现的文件描述符标志貌似就一个 *FD_CLOEXEC* 。

目前出现的文件状态标志有一些。

== /dev/fd ==
打开/dev/fd/n等效于复制描述符n。

上面的话两个意思：
# 如果你在函数中使用/dev/fd/n，那么，你得到的是一个描述符，指向n。
# 如果你在shell中使用了/dev/df/n，那么，就就是使用了n。

= 进程关系 =
*创建“终端窗口”的应用程序也被开发出来，它仿真了基于字符的终端，使得用户可以用熟悉的方式（即通过shell命令行）与主机交互。*
- 这说的应该就是gnome里面的终端。

经由终端登录至UNIX系统。终端可以是基于字符的终端、仿真简单的基于字符终端的图形终端、运行窗口系统的图形终端。

BSD终端登录
- init是id为1的进程，这是不变的。
- init对每一个ttys，fork一次。
- 子进程执行exec得到对应的getty。
- getty负责打开终端，设置文件描述符012，然后输出login：
- 当用户键入username然后回车，getty的工作就结束，其再次exec login
- login得到了用户名，然后显示password：获得用户密码，进行比对。
- 正确登录的话，login做一些权限设置的事情。
    - 这里面有一些具体的事情不知道是如何实现的

BSD网络登录
- init进程fork并exec一个inetd程序，inetd根据网络连接来fork并exec其他的进程，比如telnetd。
- 先放着这里。

每个进程除了有一个进程ID之外，还属于一个进程组。
- 每一个进程都属于一个进程组吗？

`pid_t getpgrp(void)`获得当前调用进程的组ID。

`pid_t getpgid(void)`获得pid进程的组ID。

每个进程组有一个组长进程，就是pid等于这个进程组ID的个进程。

`int setpgid(pid_t pid, pid_t pgid);`
- 设置pid进程的组ID为pgid。
- pid=gpid则，pid进程就变成组长了。
- pid=0，就认为pid为当前进程的pid。
- 如果pgid=0，则认为pid=pgid。
- 如果pid=pgid=0，就是当前进程变成组进程了。

会话是多个进程组的结合。
- `pid_t setsid(void);` 
- 如果一个进程组组长调用这个函数，就出错返回-1.
- 非组长进程可以调用导致：
    - 进程变成新会话首进程
    - 进程变成进程组组长
    - 进程没有控制终端
- `pid_t getsid(pid_t pid);`
    - pid=0，返回调用进程的会话首进程的进程组ID，不就是会话首进程的ID吗。
    - pid如果和调用进程的ID不在一个会话，那么返回。

如果一个会话有一个控制终端，则会话首进程称为控制进程。
- 会话必有一个前台进程组，其他的进程组称为后台进程组。
- ctrl+c，发送中断信号到前台进程组的所有进程
- ctrl+\，发送退出信号到前台进程组的所有进程
- 如果终端接口检测到网络断开链接，则发送挂断信号给控制进程。

`pid_t tcgetpgrp(int filedes);`
- 返回与filedes上打开的终端关联的前台进程组ID。

`pid_t tcsetpgrp(int filedes, pid_t pgrpid);`
- 设置与filedes上打开的终端关联的前台进程组为pgrpid的进程组。
- pgrpid进程组必须是同一会话中的一个进程组ID。

`pid_t tcgetsid(int filedes);`
- 得到会话首进程的进程ID。
- 该会话相关的终端描述符是filedes。

作业控制就是允许在一个终端上启动多个作业（进程组），它控制哪一个作业可以访问该终端，以及那些作业在后台运行。
- 就是我现在使用的终端上，我可以将一个工作放到后台，也可以不放后台，不放后台那么它就是前台。
- 我可以将后台的工作再放到前台上来。
- 作业控制
- bash是有作业系统的

=OVER=

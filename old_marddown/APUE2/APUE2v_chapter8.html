<!DOCTYPE html>
<html lang="en">
<head>
    <title>Chapter 8. Process Control</title>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="author" content="xrfind">
    <meta name="copyright" content="copyright (c) 三月 08, 2011 xrfind">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
 
    <link type="image/x-icon" rel="shortcut icon" href="../cssjs/css/favicon.ico"/>
	<link type="text/css"         href="../cssjs/bootstrap/css/bootstrap.css" rel="stylesheet">
	<link type="text/css"         href="../cssjs/bootstrap/css/bootstrap-responsive.css" rel="stylesheet">
	<link type="text/css"         href="../cssjs/css/custom.css" rel="stylesheet">
	<script type="text/javascript" src="../cssjs/js/jquery-1.9.1.min.js"></script>
	<script type="text/javascript" src="../cssjs/bootstrap/js/bootstrap.js"></script>
	<script type="text/javascript" src="../cssjs/js/custom.js"></script>

    <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-36694423-1']);
        _gaq.push(['_setDomainName', 'rrrui.com']);
        _gaq.push(['_trackPageview']);

        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script> 

</head>

<body>
	<div class="row-fluid">
		<div id="left-side"  class="span4"> <div class="row-fluid">
			<div class="navbar navbar-fixed-top visible-desktop">
				<div class="navbar-inner">
					<a class="brand" href="#"></a> 
					<ul class="nav">
						<li class="active"><a href="../index.html">home</a></li>
					</ul>
				</div>
			</div><!--navbar --!>

			<div id="myCarousel" class="carousel slide span12 img-polaroid  hidden-phone">
				<ol class="carousel-indicators">
					<li data-target="#myCarousel" data-slide-to="0" class="active"></li>
					<li data-target="#myCarousel" data-slide-to="1"></li>
					<li data-target="#myCarousel" data-slide-to="2"></li>
					<li data-target="#myCarousel" data-slide-to="3"></li>
					<li data-target="#myCarousel" data-slide-to="4"></li>
					<li data-target="#myCarousel" data-slide-to="5"></li>
					<li data-target="#myCarousel" data-slide-to="6"></li>
					<li data-target="#myCarousel" data-slide-to="7"></li>
					<li data-target="#myCarousel" data-slide-to="8"></li>
					<li data-target="#myCarousel" data-slide-to="9"></li>
					<li data-target="#myCarousel" data-slide-to="10"></li>
					<li data-target="#myCarousel" data-slide-to="11"></li>
					<li data-target="#myCarousel" data-slide-to="12"></li>
				</ol>
				<!-- Carousel items -->
				<div class="carousel-inner">
					<div class="item">		 <img src="../file/LRphoto/fribourg001.jpg"></div> 
					<div class="item">       <img src="../file/LRphoto/fribourg002.jpg"></div>
					<div class="item">       <img src="../file/LRphoto/fribourg003.jpg"></div>
					<div class="item">       <img src="../file/LRphoto/fribourg004.jpg"></div>
					<div class="active item"><img src="../file/LRphoto/fribourg005.jpg"></div>
					<div class="item">       <img src="../file/LRphoto/hangzhou001.jpg"></div>
					<div class="item">       <img src="../file/LRphoto/kunming001.jpg"></div>
					<div class="item">       <img src="../file/LRphoto/nanjing001.jpg"></div>
					<div class="item">       <img src="../file/LRphoto/nanjing002.jpg"></div>
					<div class="item">       <img src="../file/LRphoto/shanghai001.jpg"></div>
					<div class="item">       <img src="../file/LRphoto/someplace001.jpg"></div>
					<div class="item">       <img src="../file/LRphoto/zhoushan001.jpg"></div>
					<div class="item">       <img src="../file/LRphoto/zurich001.jpg"></div>
				</div>
				<!-- Carousel nav -->
				<a class="carousel-control left" href="#myCarousel" data-slide="prev">&lsaquo;</a>
				<a class="carousel-control right" href="#myCarousel" data-slide="next">&rsaquo;</a>
			</div>

			<div class="span12" id="profile"><div class="row-fluid">
				<div class="span4 offset1">
					<a href="http://github.com/xrfind"><img src="http://s.gravatar.com/avatar/c273e7c0a671536c4d122bc39d67c3d2?s=512" id="avatar" class="img-polaroid"></a>
				</div>
				<div class="span6 offset1 hidden-phone">
					<strong><i class="icon-user"></i> xrfind</strong><br />
					<span><i class="icon-home"></i><a href="http://wiki.rrrui.com"> wiki.rrrui.com</a></span><br />
					<span><i class="icon-envelope"></i> xrfind@gmail.com</span><br />
					<span><i class="icon-heart"></i><abbr title="c, c++, Linux"> System Engineer</abbr></span><br />
					<span><i class="icon-tasks"></i><abbr title="php, html/css/javascript, LAMP, Redis"> Web Developer</abbr></span><br />
					<span><i class="icon-road"></i> Complex Network</span>
				</div>
			</div></div>

			<div class="span12 hidden-phone" id="disqus">
			<div id="disqus_thread"></div>
			<script type="text/javascript">
				var disqus_title="Chapter 8. Process Control";
				var disqus_shortname = 'xrfindvimwiki'; // required: replace example with your forum shortname
				var disqus_identifier="Chapter 8. Process Control";

				(function() {
				var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
				dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
				(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
				})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
			<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
			</div>



		</div></div><!-- left-side --!>

		<div id="right-side" class="span8" >
			<div id="content">
			<h1>Chapter 8. Process Control</h1>

<p>17 sections.</p>

<h2>Section 8.1. Introduction</h2>

<p>introduction.</p>

<h2>Section 8.2. Process Identifiers</h2>

<p>process ID 0调度进程，swapper，不对应disk上的任何文件，是kernel的一部份，system process。process ID
1通常是init process，user process。</p>

<p>system process和user process是如何划分的？</p>

<p>6个函数，分别是pid，ppid，uid，euid，gid，egid。</p>

<h2>Section 8.3. fork Function</h2>

<p>fork之后，两个进程有自己独立的data segment，heap和stack；完全一样的。但两个进程共用text segment。</p>

<p>上面这样做很容易理解，但是现在的实现已经不这么做了，原因应该是复制操作和内存空间所带来的开销。</p>

<p>standard I/O stream中的stdout，本来就存在于一个process中，但存在于哪呢？stack中，如果新建一个stream，FILE，那
么这个算是automatic，应该在stack中。标准的3个？</p>

<p>process有自己的file descriptor table，子process会复制这部分，因此，父子process会指向同一个内核维护的file ta
ble。父子进程同时操作一个文件的时候，还是比较好处理的，因为共享文件和文件的offset，write和read文件以及相应的offset的改变是原子的。</p>

<h2>Section 8.4. vfork Function</h2>

<p>这个函数和fork类似，但其产生的子进程并不复制父进程的data text
segment，heap和stack。其运行于父进程的这些空间中，如果有修改，那么修改的就是父进程的空间，这和fork是不同的。</p>

<p>同时，在以上这些内存空间都不复制的时候，file
descriptor还是会复制一份。这个东西到底存储在进程的什么地方？或者是内核维护的，并不放在进程的空间中？</p>

<p>在子进程exit或者exec之前，父进程会sleep。</p>

<h2>Section 8.5. exit Function</h2>

<p>很好，从这一章，我可以知道的信息是process的file descriptor的确被kernel维护着。</p>

<p>不管一个process如何终止，kernel都执行相同的code，包括关闭process的file descriptor，释放memory等。</p>

<p>入口函数是main，出口就很多了，3个exit，3种last thread，1个return main，1个abort，1个signal。</p>

<p>exit涉及的几件事情：flush stream，close stream，run exit handler。现在的大多数exit实现并不close
stream，而只是flush stream和run exit handler。</p>

<p>_Exit不会运行run exit handler，flush stream与否取决于实现。UNIX上是不flush的。</p>

<p>3个exit，1个return main，2个last thread都是exit类型的，余下1个abort，1个last
thread，1个signal是非exit类型的。</p>

<ul>
<li>前者，exit类型，process terminate status，就是给予exit函数的参数。 </li>
<li>后者，非exit类型，process terminate status，是kernel产生的。 </li>
</ul>

<p>parent process总是通过使用<code>wait</code>或<code>waitpid</code>函数来获取这个process terminate
status。而不管是上面的前者还是后者，两者所做的都只是设置了一个status而已。</p>

<p>termination status是kernel转化exit status而来的，两者之间还是有差异的。</p>

<p>使用<code>wait</code>,<code>waitpid</code>得到的都是termination status，而UNIX提供了检测这些status意义的宏。</p>

<p>当一个process终止的时候，kernel会轮寻所有的process来产看是否有process为当前process的孩子。轮寻，kernel也使用这种。</p>

<p>关于zombie process，就是子process死后，没有及时被parent process回收，信息被保存在了kernel中，难道child
process可以在死后立即被parent process回收吗？不经过kernel这一步？应该是可以的，死后立即回收。</p>

<h2>Section 8.6. wait and waitpid Function</h2>

<p>process的终止总是要kernel介入的。一个process调用exit或以其他方式终止的时候，最终kernel都会接收，负责将file
descriptor和memory释放掉。kernel在完成了这些之后才会发信号到该进程的父进程去，告诉其child process已死。是这样的吧？</p>

<p>即使调用wait或者waitpid，也是在kernel将进程处理完成之后，wait才会返回的吧。 这么理解是合理的</p>

<ul>
<li><code>#include &lt;sys/wait.h&gt;</code></li>
<li><code>pid_t wait(int *statloc);</code></li>
<li><code>pid_t waitpid(pid_t pid, int *statloc, int options);</code></li>
</ul>

<p>wait函数每次返回一个，如果有多个child process都已终止，那么wait也是返回一个，不知道wait是按照何种顺序来返回的，但一次只返回一个是可
以断言的。wait还是很简单的，要么block，要么返回，要么error。</p>

<p>waitpid就复杂的多了，可以不block，可以job control。</p>

<h2>Section 8.7. waitid Function</h2>

<p>貌似更详细，和waitpid类似的多，貌似和信号的相关比较大，理解起来不复杂，复杂的是第三个参数的意义所在。 再说。</p>

<h2>Section 8.8. wait3 and wait4 Functions</h2>

<p>这两个函数提过了获取process所使用的resource信息，比如cpu time，signals
num等等。某些程序会用到……这是废话，总有程序用到的。</p>

<h2>Section 8.9. Race Conditions</h2>

<p>中文是竞争条件。多进程操作某一共享数据时会发生；解决的途径，从本节来看，signal，IPC。</p>

<h2>Section 8.10. exec Functions</h2>

<p>exec会使用disk上的new program来替换当前process的data segment，text
segment，heap，stack。也就是内存中的都替换为新的了，可以知道这个时候heap大小为0.</p>

<p>这本书里介绍的都是比较基础的函数，但只有这里用了primitive这个词，足见process的基础就是已知的这些函数：fork，exit，wait，exec
。primitive，万变不离其宗。</p>

<p>execve是这6个的基础，patchname，argv，envp。</p>

<p>对于ARG_MAX的疑问，这是参数的长度，这个长度是如何算的？括号内的所有字符数目之和？再说。</p>

<p>另一个疑问也被解答了，file descriptor在exec时候的继承问题，很早就讲过，没注意，现在这里知道了。</p>

<p>新process的ID也属于好理解的范畴。</p>

<p>关于另外一个就是，<code>argv[0]</code>就不理解了，我们在编写c program的时候，当我们在main中输出<code>argv[0]</code>的时候，我们得到的是什么？在RH
EL6上，是我在shell中调用可执行文件的方式，可以是<code>./a.out</code>，可以是<code>/home/ray/apue2v/workingDIR/a.out</code>，可
以是<code>../workingDIR/a.out</code>。就是这样。</p>

<p>而要知道的是，我在shell中执行一个可执行文件，深入理解是shell本身fork并exec了一下，那么这个时候我可以清楚的知道传递给exec的argv[0
]就是我在shell中输入的可执行文件路径。</p>

<p>而当我直接调用exec这些函数的时候，我可以指定argv[0]，我怎么指定都可以，这对于实际的功能是不影响的，这个意思就是说，如果我写一个shell，那么我
可以在这个shell中执行可执行文件，这些可执行文件是c program，如果在这些可执行文件中的某一个上有输出argv[0]的语句，你会发现你得到的输出是
“nihaoworld”，这就是我编写这个shell时设置的。</p>

<p>一般的c program也不会使用argv[0]来进行实际有意义的操作，我想不出意义所在，c
program应该实现的是有意义的功能，而不应该纠结于本身可执行文件的名字。</p>

<h2>Section 8.11. Changing User IDs and Group IDs</h2>
			</div><!-- content --!>
		</div><!-- right-side span8 --!>
	</div> <!--row-fluid --!>
</body>
</html>

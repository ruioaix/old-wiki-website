<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <title>笔记（七）——函数</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="author" content="xrfind">
    <meta name="copyright" content="copyright (c) 三月 08, 2011 xrfind">
    <link rel="stylesheet" type="text/css" href="../../css/style.css" />
    <link type="image/x-icon" rel="shortcut icon" href="../../css/favicon.ico"/>
    <script type="text/javascript" src="../../js/jquery.min.js"></script>
    <script type="text/javascript" src="../../js/moment.min.js"></script>
    <script type="text/javascript" src="../../js/custom.js"> </script> 
    <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-36694423-1']);
        _gaq.push(['_setDomainName', 'rrrui.com']);
        _gaq.push(['_trackPageview']);

        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script> 
</head>
<body>
    <div id="htop" style="width:128px;height:128px">
    </div>
    <div id="content">
        
<h1 id="toc_1">笔记（七）——函数</h1>
<ul>
<li>
函数可以认为是程序员定义的操作，另一种类似的例子就是操作符。两者都是对一定的操作数进行一定的操作，然后给出操作的结果。不一样的地方是，函数有函数名，且操作数很任意多。凸显本质的一点：两者都可以重载；这意味着同样的函数名可以对应不同的函数。

<li>
综上：可以认为函数就是一种操作，与操作符类似。

<li>
函数有重载的特性，同样的函数名可以对应于不同的函数，但是如果将操作数的类型也考虑进去，那么函数就是唯一的了。也就是说：函数名和操作数（形参）唯一的确定函数。

<li>
函数体其实是一个语句，一个块语句，快语句是<code>{}</code>，语句只有两种：<code>;</code>和<code>{}</code>。即使函数体只有一个语句，也必须加上大括号。

<li>
函数的声明和调用是两个不同的过程。

<li>
调用的时候，使用的是调用操作符，就是<code>()</code>，其操作数是函数名和实参。函数调用的时候，首先用对应的实参初始化形参，并将控制权转移给调用函数，主调函数挂起，被调函数执行。到return语句的时候，主调函数恢复执行，并将函数的返回值用作调用操作符的结果，继续执行。

<li>
形参是由实参初始化的，实参和形参的类型相同或者能隐式转换。

<li>
函数必须指定返回类型。标准cpp中，无返回类型的程序是错误的，以前的，没有则假定为int类型。

</ul>

<h2 id="toc_1.1">函数的参数传递</h2>
<ul>
<li>
每次调用函数的时候，形参就会重新创建，然后使用实参去初始化相对应的形参。这是根本原则。

</ul>

<h3 id="toc_1.1.1">非引用形参</h3>
<ul>
<li>
非引用形参包括最普通的参数传递，指针形参，const形参。

<li>
非指针形参，良种，一种非const，一种const。

<ul>
<li>
非const最普通的参数传递，可以认为就是：定义了一个局部变量，然后将实参的值copy给这个局部变量。其结果就是，实参不会被改变，同时当函数调用结束的时候，这个变量也就没有了。这里说的其实是，这种形参是不可能影响函数外部的变量的。

<li>
const类型，不太理解，貌似编译器将这个和上面的不做区别。

</ul>
<li>
指针形参，两种，一种const，一种非const。

<ul>
<li>
非const的时候，那么实参将把其值copy给形参，这个值是一个地址，指向一个单元，那么虽然形参影响不了实参，但是，形参是可以影响函数外部的变量的，它可以改变其指向但愿的值。

<li>
const形参的时候，同样的，实参copy给形参，是一个地址，这个时候，形参却不可能改变函数外部的变量了，因为虽然形参指向了一个函数外部的单元，但是形参却不可以通过其本身这个指针来改变其指向单元的值，这就是const指针。

</ul>
</ul>

<h3 id="toc_1.1.2">引用形参</h3>
<ul>
<li>
从C语言背景转到CPP的程序言，习惯通过传递指针来实现对实参的访问。在cpp中使用引用类型则更安全和更自然。

<li>
使用引用变量在我看来，就是一点，避免了复制带来的消耗。特别的大型数组和大型类的时候。

<li>
如果只是为了避免复制，而不改变其内容，那么定义为const引用是合理的。

<ul>
<li>
其实就是：应该将不需要修改的引用形参定义为const引用。

<li>
这么做的原因之一是为了防止不小心的更改了实参的值。

<li>
其二，更重要的原因是，const引用实参是不可以赋值给非const引用形参的。而不管实参是否为const引用，都是可以赋值给const引用形参的。

</ul>
<li>
指针引用形参事实上是差不多的，只不过，形参首先是一个引用，然后这个引用的对象是一个指针。

</ul>

<h3 id="toc_1.1.3">vector和其他容器类型的形参</h3>
<ul>
<li>
函数不应该有vector或其他标准库容器类型的形参，这意味这复制每个元素。

<li>
这一类可以使用引用，但实际上可以传递容器中的迭代器。

</ul>

<h3 id="toc_1.1.4">数组形参</h3>
<ul>
<li>
函数定义时候，如果形参有数组，那么这个时候形参该怎么写：

<ul>
<li>
<code>void xx(int *)</code>

<li>
<code>void xx(int[])</code>

<li>
<code>void xx(int[10])</code>

</ul>
<li>
上面的都对，意思都是第一个，指针。

<li>
所以说在函数定义的时候，形参里面放入数组的长度是容易误解的，毕竟长度是没有用处的，传递的只是数组的首地址。

<li>
有一种方法可以使长度有作用，就是引用：

<ul>
<li>
<code>void xx(int (&amp;arr)[10])</code>

<li>
这个时候数组首地址和10都使用了，编译的时候如果实参不是10个元素的int数组就会报错。

</ul>
<li>
2维矩阵：<code>int (mat*)[10]</code>这是说，mat是一个指向数组的指针，这个数组有10个元素。

</ul>

<h3 id="toc_1.1.5">main处理命令行选项</h3>
<ul>
<li>
（待续）

</ul>

<h3 id="toc_1.1.6">含有可变形参的函数</h3>
<ul>
<li>
（待续）

</ul>

<h2 id="toc_1.2">return 语句</h2>
<ul>
<li>
return 语句用于结束当前正在执行的函数，并将控制权返回给调用此函数的函数。

<li>
不带返回值的函数只能用于返回类型为void的函数；但其实void函数可以不用return语句，其在最后隐含了一个return。所以，在void函数中显式的使用return，一般是为了引起函数的强制结束。而且，void函数不是只能使用不带返回值的return语句，还可以使用带特定返回值的return语句，这个特定返回值是一个void函数的调用。

</ul>

<h2 id="toc_1.3">函数声明</h2>
<ul>
<li>
函数在调用之前必须先声明，这是否是说定义也是一种声明。

<li>
函数原型：函数返回类型，函数名，形参列表；其描述了函数的接口。

<li>
函数原型为定义函数的程序员和使用函数的程序员之间提供了接口。使用函数的程序员，大家都知道，是不需要了解函数是怎么编的，函数原型。

<li>
把放置函数声明的头文件包含在函数定义的源文件是不错的做法，这可以是编译器检查定义和声明是否一致。

<li>
默认实参

<ul>
<li>
调用函数的时候，给定实参，给定一个，那么，这个实参就对应第一个形参，后面的形参都使用默认实参。给定两个，则对应前两个。

<li>
如果，默认实参给定了第一，第三个，第二个没有给定，那么，第一个默认实参是浪费的，因为由于第二个没有给定默认实参，所以，调用函数的时候，必须至少给出两个实参。

<li>
所以，一般性的，最少使用默认实参的形参排在最前，最可能使用默认实参的形参排在最后。

<li>
默认实参可以是任何适当类型的表达式。

<li>
既可以在函数声明中，也可以在函数定义中指定默认实参，但是，在一个文件中，只能为一个形参指定默认实参一次。

<li>
如果在函数定义的形参表中提供默认实参，那么，默认实参只有在包含该函数定义的源文件中调用该函数时才有效。

</ul>
</ul>

<h2 id="toc_1.4">局部对象</h2>
<ul>
<li>
在CPP语言中，每个名字都有作用域，每个对象都有生命期。

<li>
名字的作用域是知道该名字的程序文本区；对象的生命期是程序执行中对象存在的时间。

<li>
函数是CPP中的一个非常核心的概念，包括main也是个函数；在函数中定义的形参和变量的名字只位于函数的作用域中，只在函数体中可见。

<li>
默认情况下，局部变量的生命期局限于所在函数的每次执行期间，局部变量，就是上面将的函数中定义的形参和变量。

<li>
只有当定义它的函数被调用时才存在的对象称为自动对象，自动对象在每次调用函数时创建和撤销。形参也是自动对象。

<li>
一个函数如果位于函数的作用域内，但生命期却跨越了这个函数的多次调用，这样的对象定义为static。

<li>
这中对象，在第一次经过该对想的定义语句时进行初始化，然后在程序（不是函数）结束前都不会被撤销。

</ul>

<h2 id="toc_1.5">内联函数</h2>
<ul>
<li>
函数的调用比求解表达式要慢的多，内联函数避免函数调用的开销。

<li>
内联就是将函数在程序中每个调用点上“内联地”展开；在函数返回类型前加上关键字inline。

<li>
内联说明，就是添加inline关键字，对于编译器来说只是一个建议，编译器可能将之忽略。

<li>
一般性的，内联机制用于优化小的，只有几行的而且经常被调用的函数。

<li>
递归函数的内联，大部分编译器都不支持。

<li>
一个1200行的函数也不太可能内联展开。

<li>
内联函数应该在头文件中定义，这一点不同于其他函数。

</ul>

<h2 id="toc_1.6">类的成员函数</h2>
<ul>
<li>
成员函数也是4个部分：返回类型，函数名，形参表，函数体。前面三个就是函数原型，函数原型必须在类中定义，但是，函数体既可以在类中也可以在类外定义。

<li>
类的所有成员都必须在类定义的花括号里面声明。

<li>
编译器隐式的将在类内定义的成员函数当作内联函数。

<li>
一个成员函数，当其被调用的时候，调用他的坑定是一个类的对象，那么这个成员函数包含了一个隐式的形参，这个形参就是调用他的对象的指针。这个指针的类型是const+对应的类类型的指针。

<li>
在类的定义中的成员函数，如果其形参表后面有一个const，那么，上述的指针，就变成了const+对应类类型+*+const。就是说，这个成员函数是一个const成员函数。

<li>
不可以在成员函数形参表中显示的定义this指针，但可以在成员函数函数体中显式的调用，虽然没什么必要。

<li>
在函数体外，要使用：

<ul>
<li>
<code>double sales_item::avg_price() const</code>

<li>
<code>{</code>

<li>
<code>	xxxx</code>

<li>
<code>}</code>

<li>
作用域操作符，指明函数是在类sales_item的作用域范围内定义的。

</ul>
<li>
定义类的时候，没有初始化其数据成员。

<li>
使用类的对象的时候，类通过构造函数来初始化数据成员。

<li>
构造函数可以显式定义，也可以不定义，不定义就是所谓的“合成”的构造函数，这种合成构造函数对于数据成员有不同的初始化方式，类对象则使用其本身的构造函数，内置类型和复合类型则依赖于环境。

<li>
显式定义的构造函数，可以多个，每个的形参表必定有所不同。必然是public下。

</ul>

<h2 id="toc_1.7">重载函数</h2>
<ul>
<li>
出现在相同作用域的两个函数，如果名字相同，但是形参表不同，则称为重载函数。

<li>
main函数不能重载。

<li>
两个函数声明的返回类型和形参表完全匹配，则将第二个函数声明视为第一个的重复声明（当然两者名字相同）。

<li>
两个函数声明的形参表完全相同，返回类型不同，则第二个声明是错误的。

<li>
相同作用域：如果不在相同的作用域，局部作用域将屏蔽全局作用域。在cpp中，名字查找发生在类型检查之前。

<li>
重载并不是只发生在类内部，其发生在任意位置，但就有一条，相同作用域。

<li>
通过自动提取函数调用中实际使用的实参与重载集合中各个函数提供的形参做比较，编译器实现该调用与函数的匹配。

<ul>
<li>
匹配的原则是实参类型与形参类型越接近则匹配越佳。

</ul>
<li>
匹配原则中的枚举和const（待续）

<li>
<code>bool (*pf)(const string &amp;,const string &amp;)</code>，这里的pf就是指向函数的指针，其只和返回类型和形参表有关。

<li>
可以看到指向函数的指针只于返回类型和形参表有关，这是实现重载的前提。

<li>
关于函数的指针（待续）

</ul>

<h2 id="toc_1.8">心得</h2>
<ul>
<li>
指针不是对象？指针是用来指向对象的，那么指针是否是对象。

<li>
全局作用域就是不在任何函数中。

<li>
需要完全弄清楚的几个：枚举的使用，const和引用和指针的集合。

</ul>

    </div>

    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_title="笔记（七）——函数";
        var disqus_shortname = 'xrfindvimwiki'; // required: replace example with your forum shortname
        var disqus_identifier="笔记（七）——函数";

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


    <div id="hbottom">
        <strong id="Times">Time is getting Fewer and Fewer.</strong>
        <a href="../../index.html">HomePage</a>
        <a id="Contents" href="#">Contents</a>
    </div>
</body>
</html>

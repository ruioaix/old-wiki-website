<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <title>文件I-O</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="author" content="xrfind">
    <meta name="copyright" content="copyright (c) 三月 08, 2011 xrfind">
    <link rel="stylesheet" type="text/css" href="../css/style.css" />
    <link type="image/x-icon" rel="shortcut icon" href="../css/favicon.ico"/>
    <script type="text/javascript" src="../js/jquery.min.js"></script>
    <script type="text/javascript" src="../js/moment.min.js"></script>
    <script type="text/javascript" src="../js/custom.js"> </script> 
    <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-36694423-1']);
        _gaq.push(['_setDomainName', 'rrrui.com']);
        _gaq.push(['_trackPageview']);

        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script> 
</head>
<body>
    <div id="htop" style="width:128px;height:128px">
    </div>
    <div id="content">
        
<h1 id="toc_1">文件I/O</h1>
<p>
本章是说：不带缓冲的I/O函数。
</p>

<p>
不带缓冲的I/O函数是POSIX.1的一部分，不是ISO C里的。
</p>

<p>
缓冲这个词，就是字面意思，I/O吗，输入输出，先甭管谁输入谁输出，反正就是有输入有输出，输入和输出连在一起，就像一扇门连着两个房间，那就是没有缓冲。如果输入一扇门，输出一扇门，两扇门之间还有一段通道，那么通道就算是缓冲了。
</p>

<h2 id="toc_1.1">文件描述符</h2>
<p>
就是数字，从0开始，到OPEN_MAX结束，这个OPEN_MAX是限制，也就是一个常量。
</p>

<p>
0与标准输入关联，1与标准输出关联，2与标准错误输出关联。头三个数字就没了。
</p>

<h2 id="toc_1.2">I/O函数</h2>
<ul>
<li>
<code>int open(const char *pathname, int oflag, ...);</code> 成功返回描述符，出错-1。

<li>
<code>int creat(const char *pathname, mode_t mode);</code> 同上。这个函数已经不必要了，open可以代替。

<li>
<code>int close(int filedes);</code> 成功0，出错-1。

<li>
<code>off_t lseek(int filedes, off_t offset, int whence);</code> 成功返回新的文件偏移量，出错-1。

<li>
open函数使用时，如果没有O_APPEND选项，则文件偏移量为0。

<li>
文件偏移量大于文件当前长度，会构成一个空洞，这是允许的，空洞的字节都被读为0。这里是说读为，具体的空洞可能不占用空间。

<li>
off_t就是系统数据类型了。不同的平台，内容不一样。

<li>
<code>ssize_t read(int filedes, void *buf, size_t nbytes);</code> 成功则返回读到手的字节数，若读的时候已经到文件结尾了，则0，若出错则-1。

<li>
<code>ssize_t write(int filedes, const void *buf, size_t nbytes);</code> 成功则返回写入的字节数，出错-1。

<li>
ssize_t有符号，size_t无符号

</ul>

<h2 id="toc_1.3">文件共享</h2>
<p>
UNIX系统支持在不同的进程间共享打开的文件。
</p>
<ul>
<li>
进程记录了它所打开的文件的描述符和以及对应的文件表项的指针。

<li>
内核维护文件表，每个表项说明文件状态，偏移量，和v节点指针。

<li>
v节点指针在文件系统中。

<li>
一个文件只有一个v节点。

<li>
但同一个文件可以在文件表中占据多个文件表项。

<li>
多个进程使用同一个文件表项是可能的。

<li>
多个进程使用同一个v节点是可能的，可能使用同一个文件表项，也可能各有各的文件表项，然后这些表项都指向一个v节点。

<li>
多个进程各有各的表项，所有的表项使用一个v节点也是可能的。

</ul>

<h2 id="toc_1.4">原子操作</h2>
<p>
多进程操作同一个文件时，各个进程有自己的表项，然后表项指向同一个v节点，这是最常见的。
</p>

<ul>
<li>
<code>ssize_t pread(int filedes, void *buf, size_t nbytes, off_t offset);</code>

<li>
<code>ssize_t pwrite(int filedes, const void *buf, size_t nbytes, off_t offset);</code>

</ul>

<h2 id="toc_1.5">dup和dup2函数</h2>
<ul>
<li>
<code>int dup(int filedes);</code>返回一个新的文件描述符，这个新的描述符和filedes这个描述符指向的都是同一个表项。

<li>
<code>int dup2(int filedes, int filedes2);</code>filedes2是希望得到的描述符，如果filedes2和filedes一样，那么就返回；如果filedes2已经被什么使用了，那么关闭那个，然后再打开。成功的话，filedes2和filedes指向同一个表项。

</ul>

<h2 id="toc_1.6">sync, fsync和fdtasync函数</h2>
<p>
传统的UNIX实现在内核中设有缓冲区高速缓存或页面高速缓存，大多数磁盘I/O都通过缓冲进行。
</p>
<ul>
<li>
磁盘I/O，就是对磁盘进行的I/O，向磁盘上写，从磁盘上读，向磁盘上写的时候大多应该是内存吧，也就是说将内存中的东西写入磁盘上，而从磁盘上读，显然也是将磁盘上的文件读到内存中。

<li>
不过对于读，貌似没有要求，重点在写上。

<li>
就是在内存和磁盘之间的I/O，有一个缓冲。

<li>
将数据写入文件时，内核将数据放入缓冲中，如果缓冲中没有写满，则不输出。

<li>
写满了，或者内核需要重用缓冲来存放其他磁盘块数据时，就将缓冲放入输出队列。

<li>
等输出队列一个一个的输出，也就是实际的I/O操作。

<li>
这种方式就是延迟写。

<li>
为了保证磁盘上实际文件系统与缓冲区高速缓存中内容的一致性，UNIX提供了sync，fsync和fdatasync三个函数。

</ul>

<p>
<code>int fsync(int filedes);</code>对文件filedes这一个文件起作用，并且等待写磁盘操作结束。
</p>

<p>
<code>int fdatasync(int filedes);</code>同上类似，但上面的函数将文件的属性都修改了，本函数只是写入数据，不管属性等其他非数据部分。
</p>

<p>
<code>void sync(void);</code>将缓冲排入写队列。并不要求实际磁盘操作。
</p>

<h2 id="toc_1.7">fcntl函数</h2>
<p>
<code>int fcntl(int filedes, int cmd, ...);</code>
函数可以改变已经打开的文件的性质。
</p>

<p>
第一个参数就是打开文件的文件描述符。函数的作用取决于第二个参数。根据第二个参数，第三个参数可以变换。
</p>

<p>
该函数的5种功能：
</p>
<ol>
<li>
复制一个现有的描述符。和dup一个意思，但比dup更灵活，dup是最小可用的，本函数是从某个值开始最小可用的。

<li>
获得/设置文件描述符标记

<li>
获得/设置文件状态标记

<li>
获得/设置异步I/O所有权

<li>
获得/设置记录锁

</ol>

<p>
文件描述符，文件描述符标志，文件状态，文件状态标志。
</p>

<p>
目前出现的文件描述符标志貌似就一个 <strong>FD_CLOEXEC</strong> 。
</p>

<p>
目前出现的文件状态标志有一些。
</p>

<h2 id="toc_1.8">/dev/fd</h2>
<p>
打开/dev/fd/n等效于复制描述符n。
</p>

<p>
上面的话两个意思：
</p>
<ol>
<li>
如果你在函数中使用/dev/fd/n，那么，你得到的是一个描述符，指向n。

<li>
如果你在shell中使用了/dev/df/n，那么，就就是使用了n。

</ol>

    </div>

    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_title="文件I-O";
        var disqus_shortname = 'xrfindvimwiki'; // required: replace example with your forum shortname
        var disqus_identifier="文件I-O";

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


    <div id="hbottom">
        <strong id="Times">Time is getting Fewer and Fewer.</strong>
        <a href="../index.html">HomePage</a>
        <a id="Contents" href="#">Contents</a>
    </div>
</body>
</html>

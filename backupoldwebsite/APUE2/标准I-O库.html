<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <title>标准I-O库</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="author" content="xrfind">
    <meta name="copyright" content="copyright (c) 三月 08, 2011 xrfind">
    <link rel="stylesheet" type="text/css" href="../css/style.css" />
    <link type="image/x-icon" rel="shortcut icon" href="../css/favicon.ico"/>
    <script type="text/javascript" src="../js/jquery.min.js"></script>
    <script type="text/javascript" src="../js/moment.min.js"></script>
    <script type="text/javascript" src="../js/custom.js"> </script> 
    <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-36694423-1']);
        _gaq.push(['_setDomainName', 'rrrui.com']);
        _gaq.push(['_trackPageview']);

        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script> 
</head>
<body>
    <div id="htop" style="width:128px;height:128px">
    </div>
    <div id="content">
        
<h1 id="toc_1">标准I/O库</h1>
<p>
前面说了很多的文件I/O操作，不同的头文件，操作的都是linux上直接的文件目录。
</p>

<p>
对，前面的文件I/O，就是告诉你怎么操作linux上的文件和目录。
</p>

<p>
接下来的每一个章节，又会告诉你怎么操作linux上的这个那个。
</p>

<p>
文件I/O操作要么针对文件描述符，要么是直接的pathname。而标准I/O则是围绕流进行的。
</p>

<p>
流，暂时不知道是个什么东西。但是其一个属性是定向，定向就是其所读的字节是单字节还是多字节。
</p>
<ul>
<li>
<code>#include &lt;stdio.h&gt;</code>

<li>
<code>#include &lt;wchar.h&gt;</code>

<li>
<code>int fwide(FILE *fp, int mode);</code>

</ul>

<p>
<strong>对一个进程预定义了三个流，并且这三个流可以自动地被进程使用，它们是：标准输入、标准输出、标准出错。</strong>
</p>
<ul>
<li>
原来这三个是对进程来说的，其实也是必然是对进程来说的。

<li>
原来这三个是流啊。

<li>
这三个通过预定义文件指针stdin、stdout、stderr加以使用。

</ul>

<h2 id="toc_1.1">缓冲</h2>
<p>
标准I/O库提供缓冲的目的是尽可能减少使用read和write调用的次数。
</p>

<p>
标准I/O提供了三种类型的缓冲：
</p>
<ol>
<li>
全缓冲——I/O缓存区填满后才进行实际I/O操作。在一个流上执行第一次I/O操作时，相关标准I/O函数通常调用malloc获得需使用的缓冲区。

<ul>
<li>
在一个流上执行I/O操作，也就是说流需要和某一个确切的文件联系起来。

<li>
全缓冲通常用于驻留在磁盘上的文件，也就是操作磁盘上的文件，比如写入数据到磁盘文件上的时候。

<li>
缓冲区可由标准I/O自动冲洗（填满），也可以调用函数fflush冲洗。冲洗——将缓冲区写入磁盘。

<li>
对于终端来说，flush意味着丢弃存储在缓冲区中的数据。

</ul>
<li>
行缓冲

<ul>
<li>
当在输入和输出中遇到换行符时，标准I/O库执行I/O操作。

<li>
对于终端来说，一般都使用行缓冲。

<li>
终端的输入，也就是在回车之后被读入的。写输入的过程是行缓冲吗？

<li>
终端的输出？

<li>
流和终端联系的时候，通常使用行缓冲。

<li>
行缓冲的限制

<ul>
<li>
行缓存的缓冲区长度固定，当填满时，即使没有换行符，也执行I/O

<li>
从内核获取数据，意思是要求内核使用read函数读数据过来，虽然我明白这句话的意思，但我想不到合适的比喻，就是说标准I/O要求从一个带行缓冲的流中得到输入数据时，那么就冲洗所有行缓冲的输出流，因为数据可能已经在该缓冲区了。。。。你妈的，什么乱七八糟的。。。

</ul>
</ul>
<li>
不带缓冲

<ul>
<li>
标准出错流stderr通常是不带缓冲的。

</ul>
</ol>

<p>
<code>void setbuf(FILE *restrict fp, char *restrict buf);</code>
<code>int setvbuf(FILE *restrict fp, char *restrict buf, int mode, size_t size);</code>
</p>

<p>
一般而言，应由系统选择缓冲区的长度，并自动分配缓冲区。在这种情况下关闭此流时，标准I/O库将自动释放缓冲区。
</p>

<p>
任何时候，我们都可以强制冲洗一个流：
</p>
<ul>
<li>
<code>#include &lt;stdio.h&gt;</code>

<li>
<code>int fflush(FILE *fp);</code>

<ul>
<li>
此函数使该流所有未写的数据都被传送至内核。

<li>
内核负责写入磁盘文件吗，write函数，所以也就是说传给内核，内核输出。

</ul>
</ul>

<h2 id="toc_1.2">打开流</h2>
<p>
打开一个标准I/O流
</p>
<ul>
<li>
<code>FILE *fopen(const char *restrict pathname, const char *restrict type);</code>

<ul>
<li>
第一个函数打开一个文件，并返回一个流。

<li>
返回的流和这个文件就结合起来了。

<li>
以后对流的操作，就是对文件的操作。

</ul>
<li>
<code>FILE *freopen(const char *restrict pathname, const char *restrict type, FILE *restrict fp);</code>

<ul>
<li>
第二个函数在一个指定的流上打开一个文件

<li>
并返回这个流。

<li>
此函数一般用于将一个指定的文件打开为一个预定义的流。

</ul>
<li>
<code>FILE *fdopen(int filedes, const char *type);</code>

<ul>
<li>
第三个函数获取一个文件描述符，将返回的流与之结合。

<li>
特殊类型的文件不可以被fopen打开，所以用特殊的函数打开然后返回一个描述符，这个描述符就可以被这个函数使用了。

</ul>
<li>
fdopen对于为写而打开的并不截断该文件。fdopen得到的是描述符。也就是已经被打开了，打开的时候使用的函数决定了是否截断。fdopen本身不截断任何关联的文件。

</ul>

<p>
当进程正常终止时（直接调用exit函数，或从main函数返回），则所有带未写缓冲数据的标准I/O流都会被冲洗，所有打开的标准I/O流都会被关闭。
</p>

<h2 id="toc_1.3">读和写流</h2>
<p>
一次读一个字符
</p>
<ul>
<li>
<code>#include &lt;stdio.h&gt;</code>

<li>
<code>int getc(FILE *fp);</code>

<li>
<code>int fgetc(FILE *fp);</code>

<li>
<code>int getchar(void);</code>

<li>
这三个函数是对一个字符，也就是一个unsigned char，现在这三个函数返回的是int类型，也就是执行了从unsigned char到int的转换，这样不会有任何的损失。

<li>
这三个函数在出错和到达文件尾端（就是没成功读取），这三个函数都返回同样的值。

<li>
<code>int ferror(FILE *fp);</code>

<ul>
<li>
是否出错

</ul>
<li>
<code>int feof(FILE *fp);</code>

<ul>
<li>
是否到达文件尾部。

</ul>
<li>
<code>void clearerr(FILE *fp);</code>

</ul>

<p>
输入流，输出流，是什么意思。
</p>
<ul>
<li>
输入，记得read函数，就是读，读就是输入，读什么，读文件，那么输入流呢，就是从流中读。

<li>
输出流，就是向流中写入。

</ul>

<p>
输出一个字符到流中
</p>
<ul>
<li>
<code>int putc(int c, FILE *fp);</code>

<li>
<code>int fputs(int c, FILE *fp);</code>

<li>
<code>int putchar(int c);</code>

</ul>

<h2 id="toc_1.4">每次一行I/O</h2>
<p>
每次从流中读一行
</p>
<ul>
<li>
<code>char *fgets(char *restrict buf, int n, FILE *restrict fp);</code>

<li>
<code>char *gets(char *buf);</code>

<ul>
<li>
fgets的buf总是以null字符结尾的。

<li>
如果一行不到n-1的长度，那么读入的是完整的行，然后加上null

<li>
如果一行超过了n-1的长度，那么读入了n-1个字符，也就是不完整的行，然后加上null。

<ul>
<li>
然后fgets的下一次调用会继续读该行。

</ul>
<li>
gets不指定缓冲区长度，也就是说比如它有100的长度，但终端一行写入了110，那么buf之后的10个字符空间就被非法使用了，也就是缓冲区溢出了。

<li>
gets因为从终端读入，所以最后一个换行符总是不保存的。（终端输入最后一个回车吗）。

</ul>
</ul>

<p>
每次向流中写入一行
</p>
<ul>
<li>
<code>int fputs(const char *restrict str, FILE *restrict fp);</code>

<li>
<code>int puts(const char *str);</code>

<ul>
<li>
fputs将以null结尾的字符串写入流，但不要求null前面是换行符，也就是说不要求字符串是一行。null字符不写入。

<li>
puts将以null结尾的字符串写入流，null字符不写入，然后再写入一个换行符。

</ul>
</ul>

<h2 id="toc_1.5">标准I/O的效率</h2>
<p>
系统调用与普通的函数调用相比通常需要花费更多的时间。
</p>

<p>
对于大多数比较复杂的应用程序，最主要的用户cpu时间是由应用本身的各种处理消耗的，而不是由标准I/O例程消耗的。
</p>

<h2 id="toc_1.6">二进制I/O</h2>
<p>
二进制文件中会包含null和换行符，这些都是有用的。
</p>

<p>
如果使用fputs和fgets，那么会忽略null，造成数据读取和写入的失败。
</p>

<p>
二进制I/O操作的函数
</p>
<ul>
<li>
<code>#include &lt;stdio.h&gt;</code>

<li>
<code>size_t fread(void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);</code>

<li>
<code>size_t fwrite(const void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);</code>

<li>
使用二进制I/O的基本问题是，它只能用于读在同一个系统上已写的数据。

<li>
不同系统上的二进制数据格式可能不同。

</ul>

<h2 id="toc_1.7">定位流</h2>
<p>
定位流，定位文件。有些混乱。
</p>

<h2 id="toc_1.8">格式化I/O</h2>
<p>
格式化输出
</p>
<ul>
<li>
<code>#include &lt;stdio.h&gt;</code>

<li>
<code>int printf(const char *restrict format, ...);</code>

<li>
<code>int fprintf(FILE *restrict fp, const char *restrict fomat, ...);</code>

<li>
<code>int sprintf(char *restrict buf, const char *restrict format, ...);</code>

<li>
<code>int snprintf(char *restrict buf, size_t n, const char *restrict format, ...);</code>

<ul>
<li>
sprintf会在buf尾部加上一个null，但该字节不包含在返回值中。

</ul>
</ul>

<p>
格式化输入
</p>
<ul>
<li>
<code>int scanf(const char *restrict format, ...);</code>

<li>
<code>int fscanf(FILE *restrict fp, const char *restrict format, ...);</code>

<li>
<code>int sscanf(const char *restrict buf, const char *restrict format, ...);</code>

</ul>

<h2 id="toc_1.9">实现细节</h2>
<p>
每一个标准I/O流都有一个与其相关联的文件描述符。
</p>
<ul>
<li>
<code>int fileno(FILE *fp);</code>

</ul>

<p>
RHEL6：
</p>
<ul>
<li>
当标准输入、标准输出连至终端时，它们是行缓冲的，行缓冲区的长度是1024字节；也就是说，如果要将2048字节的行写到标准输出，则要进行两次write系统调用，就是说1024满了的时候，调用一次write，将缓冲区的内容写入到标准输出描述符里面。然后再一次。

<li>
当标准输入、标准输出连至普通文件时，它们就变成是全缓冲的，其缓冲区长度是该文件系统优先选用的I/O长度。

<li>
标准出错是非缓冲的。

</ul>

<p>
流总是和文件描述符关联。当写入的时候，对于流来说，就是fputs，fputc，printf等等，这些都是将一些写入流中，准确的说是写入流缓冲区中，然后，在流缓冲区满了的时候，或者其他一些满足要求的时候，内核就会调用write函数，将流缓冲区中内容写入流所对应的文件描述符中。
</p>

<p>
当输出的时候，过程应该是相反的，先是内核读取文件描述符所对应的文件的内容到缓冲区，读满整个缓冲区？然后，使用getc，fgetc，fgets，scanf等来从缓冲区读取内容？是这样吗？
</p>

<p>
或者，不同的缓冲区类型不能一概而论。
</p>

<p>
或许是这样的，流就是缓冲，文件就是文件描述符，write和read直接操作文件描述符，直接操作，一次一个内核调用，无缓冲。底层总是这么实现的。然后在其上，出现了缓冲，流，流的出现就是为了减少write和read的直接调用次数，所以，设置了缓冲区，缓冲区满了你才能write，read的时候，也是直接从对应的文件读一个缓冲区长度的数据，放在缓冲区，然后，上面的你慢慢读，什么时候缓冲区空了，read再给你整满满一区。概念上应该是这么个概念。
</p>

<p>
实现的话，比如fgetc，读一个字符，从流中读一个字符，你使用这个函数的时候，参数是一个流，这个流已经和一个文件描述符对应了，你这里读一个字符，实际上，内和调用read读取的可不是一个字符。上面也做了实验，fgetc和每次读一个字符的read函数之间的比较，read函数读了2亿次，也就是说文件有2亿字符，所以读了两亿次吗，但是这2亿个字符，fgetc只引起了25222次系统调用，这说明了什么，说明了fgetc调用系统函数时并不是每次读一个字符，它读的更多，放在了缓冲里而已。
</p>

<p>
fputc也好理解，每次放在了缓冲里，最后一下调用系统函数，系统函数将缓冲区的数据一次放入文件描述符的文件里。
</p>

<p>
fgets呢，如何理解。底部应该是和fgetc一致的，事实上，fgets很可能是调用fgetc的，如果是这样，我就理解了。但是fgets还可能调用的是memccpy函数，这个我就不知道了，但也应该是有缓冲区的存在，memccpy操作的也应该是缓冲区吧。
</p>

<p>
那printf呢，这个是和终端联系在一起的，输出函数，它将内容交给了终端流，终端流什么时候实际的将其缓冲区内容输出到终端输出描述符呢，满了的时候吧。
scanf呢，也和终端联系在一起，首先是从终端获取数据，这个应该是立即的，首先，从终端输入文件描述符中得到数据，缓冲区大概也就那么大，然后获得数据。可能对于scanf来说，缓存区反而是多余的步骤。但存在即有理。
</p>

<p>
其他的一些函数，比如fprintf，我就好理解了，放入流中，其实先理解了这种函数，再去理解printf要好理解的多。
</p>

<p>
对于fscanf，也是，从流中取数据放入变量中，也是可以理解的。
</p>

<p>
这些所有的标准I/O函数，都是对应与流，而流对应与文件描述符，文件描述符对应于系统调用，流就是缓冲区，标准I/O操作的都是缓冲区。
</p>
 
<h2 id="toc_1.10">临时文件</h2>
<p>
RHEL6上使用tmpnam时，编程给出了警告，说使用mkstemp比较安全。
</p>

<h2 id="toc_1.11">标准I/O的替代软件</h2>
<p>
当使用每次一行的函数fgets和fputs的时候，通常进行两次复制，一次在内核和标准I/O的缓冲之间（也就是调用read和write的时候），第二次是在标准I/O缓冲区和用户程序中的行缓冲区之间。
</p>
<ul>
<li>
这里才发现还有个用户程序中的行缓冲区之间，这个是啥呢？

<li>
是fgets从缓冲区取数的过程，这里的行缓冲区更多的是一个数组类型的buf吧。

</ul>

<h1 id="toc_2">OVER</h1>

    </div>

    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_title="标准I-O库";
        var disqus_shortname = 'xrfindvimwiki'; // required: replace example with your forum shortname
        var disqus_identifier="标准I-O库";

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


    <div id="hbottom">
        <strong id="Times">Time is getting Fewer and Fewer.</strong>
        <a href="../index.html">HomePage</a>
        <a id="Contents" href="#">Contents</a>
    </div>
</body>
</html>
